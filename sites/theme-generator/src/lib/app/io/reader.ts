import { colorShades } from "../constants";
import { nanoid } from "nanoid";
import type { ColorSet, ColorShadeObject, ColorShade, ThemetteTheme, InternalOptions } from "../types";

/**
 * Converts a css string to a `ThemetteTheme` if possible, throws an error if it fails.
 * Also grabs the internal options if available
 *
 * Right now the `readTheme` fn expects contrasts to be present in the css string, this
 * might be limiting for users who want to import files not generated by us but follows the appropriate format.
 */
export function readTheme(css: string): { theme: ThemetteTheme; options: Partial<InternalOptions> } {
  /**
   * matches set, shade, and value:
   * - `(?<!(?:-contrast))` ignores contrast variables
   * - `(?<!(?:-\d+-\d+))` ignores generated pairing variables
   */
  const colorRegex = /^--color-(.+?)(?<!(?:-contrast))-(\d+)(?<!(?:-\d+-\d+)):\s*([^;]+);/;
  const contrastRegex = /^--color-(.+?)-contrast-(\d+):\s*([^;]+);/;

  const lines = css.split("\n").map((line) => line.trim());

  const colorLines = lines.filter((line) => line.startsWith("--color-"));

  const colors = colorLines
    .map((line) => line.match(colorRegex))
    .filter((matches) => matches !== null)
    .filter((matches) => matches.length === 4 && colorShades.includes(matches[2] as any))
    .map(([, set, shade, value]) => ({ set, shade, value }));

  const contrasts = colorLines
    .map((line) => line.match(contrastRegex))
    .filter((matches) => matches !== null)
    .filter((matches) => matches.length === 4 && colorShades.includes(matches[2] as any))
    .map(([, set, shade, value]) => ({ set, shade, value }));

  const sets = [...new Set([...colors.map(({ set }) => set), ...contrasts.map(({ set }) => set)])];

  const theme = sets.map((set) => {
    // create an object for the set
    const colorSet: ColorSet = {} as ColorSet;
    colorSet.contrasts = {} as ColorShadeObject;
    colorSet.name = set;
    colorSet.id = nanoid();

    // place the colors in
    colors
      .filter((color) => color.set === set)
      .forEach((color) => {
        colorSet[color.shade as ColorShade] = color.value;
      });

    // place the contrasts in
    contrasts
      .filter((contrast) => contrast.set === set)
      .forEach((contrast) => {
        colorSet.contrasts[contrast.shade as ColorShade] = contrast.value;
      });

    return colorSet;
  });

  const options = lines
    .filter((line) => line.startsWith("themette-internal"))[0]
    ?.split(",")
    .slice(1)
    .map((keyVal) => keyVal.split(":"))
    .reduce((obj: Partial<InternalOptions>, [key, val]) => {
      if (key === "foreground") obj.foreground = val;
      else if (key === "background") obj.background = val;
      return obj;
    }, {} as Partial<InternalOptions>);

  if (!theme.every((set) => isColorSet(set))) throw Error("Bad Read!");
  return {
    theme,
    options,
  };
}

function isColorSet(set: any): set is ColorSet {
  if (typeof set.name !== "string" || typeof set.contrasts !== "object") return false;
  return isColorShadeObject(set.contrasts) && isColorShadeObject(set);
}

/**
 * Only checks if the given set fits a the `ColorShadeObject` type, it does not check
 * if the values within is actually valid CSS.
 */
function isColorShadeObject(set: any): set is ColorShadeObject {
  return colorShades.every((shade) => typeof set[shade] === "string");
}
